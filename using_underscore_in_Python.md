# Способы использования символа _ в Python.

1) Самый очевидный способ: по PEP8 символ _ используется при разделении слов в имени переменной.
```Python
def convert_object_to_dict(self):
	//...
```

2) Самый неочевидный способ: при выполнении вычислений в консоли можно обратиться к последнему полученному значению.
```Python
>>> 10 + 10
20
>>> _ * 3
60
```

3) Ещё один до крайности неочевидный способ: при форматировании целых чисел.
```Python
test_number = 1_000_000_000
print(test_number)
>>> 1000000000
```
Очень удобно при задании констант, обозначающих максимально допустимый размер чего-либо в байтах.

4) Второй по популярности способ использования - обозначение неважного для программы значения:
```Python
for _ in range(n):
	// действие 1
	// действие 2
```
Можно использовать вполне привычный для циклов i, но любая IDE и любой интерпретатор обязательно укажут на то, что полученное значение нигде не используется.

5) При извлечении значений из коллекций, например
```Python
object_list = [obj1, obj2, obj3, objn]
a, _, b, _ = object_list
```
В таком случае в переменной a будет obj1, в переменной b - obj3, а в `_` окажется последнее присвоенное значение (objn). 

6) В переменную можно положить и целый кусок коллекции:
```Python
object_list = [obj1, obj2, obj3, objn]
begin, *_, end = object_list
```
Символ `*` обычно используется для развернутого обращения к переменной (использовать не саму переменную, а список или кортеж значений, из которых оно состоит). В _ будет находиться `[obj2, obj3]`

7) При создании классов все создаваемые в конструкторе поля по умолчанию являются публичными (аналог public в C-подобных языках), как и методы. Но что делать если обращение к полю нужно допустить только из методов самого класса и его наследников? В C-подобных языках это решается служебным словом protected. В Python на помощь приходит всё тот же символ.
```Python
from uuid import uuid4

class Sprite:
	def __init__(self):
		self._id = uuid4()
```
Protected в Python работает интересно (как и в других языках, т.к. полу-private/полу-public реализовать сложнее, чем чистые private и public), например, при использовании IDE может возникнуть такая ситуация:
```Python
sprite = Sprite
sprite.
```
После нажатия символа точка всплывёт подсказка с возможными переменными и методами, но переменной `_id` там не будет. Тем не менее, никто не мешает нам её ввести вручную и код отработает штатно. Так себе защита переменной, на самом деле.

8) Для полей и методов, доступных только в методах самого класса, нужно использовать двойное подчёркивание:
```Python
from uuid import uuid4

class Sprite:
	def __init__(self):
		self.__id = uuid4()
	
	def _get_id(self):
		return self.__id

```
Таким образом, у нас есть защищённый getter для получения id, но нет никакой возможности изменить id нечаянно или по злому умыслу и испортить работу приложения.

9) Dunder-методы. Это методы, заранее определённые Python, как методы с двойным подчёркиванием до и после имени. Если мы создали класс Sprite:
```Python
from uuid import uuid4

class Sprite:
	def __init__(self):
		self.__id = uuid4()
```
то попытка сложить sprite1 и sprite2 приведёт к ошибке, т.к. никому не известно, можно ли складывать объекты типа Sprite, и как это делается.

Если определить метод `__add__`:
```Python
from uuid import uuid4

class Sprite:
	def __init__(self):
		self.__id = uuid4()
	
	def __add__(self, otherSprite):
		# много кода
		return # какой-то итоговый Sprite
```
в котором описать, как при изменяется первый объект при прибавлении второго объекта, то операция `sprite1+sprite2` вернёт нам легальный итоговый Sprite-объект.
