<!DOCTYPE html>
<html>
<head>
  <title>
    Yet another one IT blog.
  </title>
</head>
<body>
  <h1>Способы использования символа _ в Python.</h1>

<p>1) Самый очевидный способ: по PEP8 символ _ используется при разделении слов в имени переменной.</p>
<code style="white-space: pre;">
def convert_object_to_dict(self):
  //...
</code>

<p>2) Самый неочевидный способ: при выполнении вычислений в консоли можно обратиться к последнему полученному значению.</p>
<code style="white-space: pre;">
>>> 10 + 10
20
>>> _ * 3
60
</code>

<p>3) Ещё один до крайности неочевидный способ: при форматировании целых чисел.</p>
<code style="white-space: pre;">
test_number = 1_000_000_000
print(test_number)
>>> 1000000000
</code>
<p>Очень удобно при задании констант, обозначающих максимально допустимый размер чего-либо в байтах.</p>

<p>4) Второй по популярности способ использования - обозначение неважного для программы значения:</p>
<code style="white-space: pre;">
for _ in range(n):
  // действие 1
  // действие 2
</code>
<p>Можно использовать вполне привычный для циклов i, но любая IDE и любой интерпретатор обязательно укажут на то, что полученное значение нигде не используется.</p>

<p>5) При извлечении значений из коллекций, например</p>
<code style="white-space: pre;">
object_list = [obj1, obj2, obj3, objn]
a, _, b, _ = object_list
</code>
<p>В таком случае в переменной a будет obj1, в переменной b - obj3, а в _ окажется последнее присвоенное значение (objn).</p>

<p>6) В переменную можно положить и целый кусок коллекции:</p>
<code style="white-space: pre;">
object_list = [obj1, obj2, obj3, objn]
begin, *_, end = object_list
</code>
<p>Символ `*` обычно используется для развернутого обращения к переменной (использовать не саму переменную, а список или кортеж значений, из которых оно состоит). В _ будет находиться [obj2, obj3]</p>

<p>7) При создании классов все создаваемые в конструкторе поля по умолчанию являются публичными (аналог public в C-подобных языках), как и методы. Но что делать если обращение к полю нужно допустить только из методов самого класса и его наследников? В C-подобных языках это решается служебным словом protected. В Python на помощь приходит всё тот же символ.</p>
<code style="white-space: pre;">
from uuid import uuid4

class Sprite:
  def __init__(self):
    self._id = uuid4()
</code>
<p>Protected в Python работает интересно (как и в других языках, т.к. полу-private/полу-public реализовать сложнее, чем чистые private и public), например, при использовании IDE может возникнуть такая ситуация:</p>
<code style="white-space: pre;">
sprite = Sprite
sprite.
</code>
<p>После нажатия символа точка всплывёт подсказка с возможными переменными и методами, но переменной `_id` там не будет. Тем не менее, никто не мешает нам её ввести вручную и код отработает штатно. Так себе защита переменной, на самом деле.</p>

<p>8) Для полей и методов, доступных только в методах самого класса, нужно использовать двойное подчёркивание:</p>
<code style="white-space: pre;">
from uuid import uuid4

class Sprite:
  def __init__(self):
    self.__id = uuid4()
  
  def _get_id(self):
    return self.__id

</code>
<p>Таким образом, у нас есть защищённый getter для получения id, но нет никакой возможности изменить id нечаянно или по злому умыслу и испортить работу приложения.</p>

<p>9) Dunder-методы. Это методы, заранее определённые Python, как методы с двойным подчёркиванием до и после имени. Если мы создали класс Sprite:</p>
<code style="white-space: pre;">
from uuid import uuid4

class Sprite:
  def __init__(self):
    self.__id = uuid4()
</code>
<p>то попытка сложить sprite1 и sprite2 приведёт к ошибке, т.к. никому не известно, можно ли складывать объекты типа Sprite, и как это делается.</p>

<p>Если определить метод `__add__`:</p>
<code style="white-space: pre;">
from uuid import uuid4

class Sprite:
  def __init__(self):
    self.__id = uuid4()
  
  def __add__(self, otherSprite):
    # много кода
    return # какой-то итоговый Sprite
</code>
<p>в котором описать, как при изменяется первый объект при прибавлении второго объекта, то операция `sprite1+sprite2` вернёт нам легальный итоговый Sprite-объект.</p>

<p>Какие способы использования символа _ я мог забыть?</p>