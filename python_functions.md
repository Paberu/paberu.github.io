# Функции в Python

## Пользовательские, сторонние и встроенные.

### Пользовательские

```Python
def имя_функции(параметры):
    тело_функции
    return результат  # опционально
```
Параметров может и не быть, например, если функция должна что-то сгенерировать и отдать.

Функция может возвращать несколько значений: `return good, bad, ugly`. Если количество возвращаемых значений и количество переменных, в которые они сохраняются, не совпадает, в последнюю переменную упадёт кортеж из оставшихся значений. Функция, не имеющая `return` незаметно (неявно) возвращает `None`.

### Сторонние

По сути своей, те же пользовательские, с той лишь разницей, что написал их кто-то другое (возможно, что и мы сами, когда создавали библиотеку или фреймворк), и в нашем коде просто производится импорт функции, класса или всего пакета.

### Встроенные

Те же сторонние просто написаны авторами языка, входят в стандартную библиотеку. 

## По количеству аргументов

### Функции с фиксированным количеством аргументов

Параметры передаются через запятую, заданных по умолчанию параметров нет, количество передаваемых аргументов должно совпадать с определением функции.

### Функции с плавающим количеством аргументов

Можно реализовать несколькими способами:
- параметры передаются через запятую, но у некоторых параметров есть значения по умолчанию (тогда можно не указывать значения тех, что не отличаются от дефолтных, например, `sep=' '` и `end='\n'` при вызове `print`);
- параметры передаются списком `*args`;
- параметры передаются словарём `**kwargs`.

## По структуре

### Внутренние функции

Логичнее всего создавать их для того, чтобы выделить повторяющийся во внешней функции код, но при этом не плодить методы в классе или функции в модуле. Так реализуется _принцип единой ответственности_.

Понимание внутренних (они же вложенные) функций необходимы для применения более сложных концепций - замыканий и декораторов.

### Замыкания

Функция возвращает внутреннюю функцию, вместе с которой в памяти хранятся внешний по отношению к ней объект (статический или динамический). Такой подход позволят на ходу генерировать функции, просто вызывая внешнюю с нужными параметрами.

### Декораторы

По сути, декоратор - это синтаксический сахар для вызова функции с именем декоратора, аргументом которой будет декорируемая функция. Например, функция может просто вычислять и возвращать результат вычислений, но если таких функций много, то все проверки прав доступа имеет смысл вынести в функцию-декоратор, которая и будет проверять, имеет ли пользователь право запрашивать тот или иной результат вычислений. Нет нужды проверять это в каждой функции или в каждом классе, но при этом можно написать достаточно дотошную проверку, потому что это не разбарабанит код.

### Анонимные (lambda)

Их не создают по правилам создания пользовательских функций, у них нет имени и их не собираются использовать повторно. Поэтому они и анонимные.
```Python
lambda argument: manipulate(argument)
```
Они идентичны обыкновенным функциям, но их удобно использовать, например, при вычислении принципа сортировки кортежа кортежей или списка списков.

### Рекурсивные

Функции, которые вызывают сами себя и при этом используют результат предыдущего вызова.  Для этого прописывается 2 ситуации:
- граничная, при которой функция завершает работу и возвращает результат;
- рекурсивный, при котором функция вызывает саму себя, но с некоторыми поправками с аргументах.

Рекурсивные функции всегда медленнее итерационных, нагружают стек вызовов и затрудняют понимание код. Для ускорения можно использовать мемоизацию: сама функция перестаёт быть рекурсивной, при этом внутри неё создаётся внутренняя рекурсивная функция и некий параметр, в котором аккумулируются результаты промежуточных вызовов внутренней функции.