# Реализация истинного наследования с помощью паттерна Visitor

Представим гипотетическую ситуацию: я делаю пошаговую стратегию в стиле HoMM3 (маркетологи что-то там исследовали и приняли решение создать очередного клона). Рабочее название проекта - Spear&Spirit.

Все объекты, которые придётся отрисовать на экране делятся на ряд категорий:
- Местность.
- Объекты на карте.
- Юниты.
- Герои.

Местность делится на 2 группы:
- Статическая (любой тип земли).
- Динамическая (море, оно же волнуется).

Объекты на карте делятся на 2 группы:
- Статические (любые препятствия и здания на карте).
- Динамические (башни, окруженные плывущими облаками, мельницы, водопады).

Юниты и герои всегда динамические (юниты шевелятся на месте, герои шевелятся во время перемещения на карте).

Базовые классы + 2 примера классов, описывающих местность, приведены здесь:
https://github.com/Paberu/Spear_and_Spirit/blob/27ad463e274997d408935a27bcf799d817571a13/GraphicObject.py

В этом коде в классе DynamicGraphicObject переопределяется метод draw() родительского класса GraphicObject. Надо переделать. Что характерно, PyCharm всё устраивает.

Есть два варианта:
1) Абстрактный класс в верхушке иерархии GraphicObject с абстрактным методом draw() и два наследника - StaticGraphicObject и DynamicStaticObject.
2) Оставить иерархию, как есть, и использовать её в качестве полигона для изучения паттерна Visitor.

Я, пожалуй, совмещу:
https://github.com/Paberu/Spear_and_Spirit/blob/dc79f32deda6ba8e5a03ed97422e9548ec60dca2/GraphicObject.py

Класс, реализующий паттерн Visitor, называется GraphicProcessor. 