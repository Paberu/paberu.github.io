# Ясный код-2

2.1. Допустим, класс Героя в клоне HoMM3 содержит в себе артефакты, которые он экипирует и возвращает в инвентарь; войска, которые он перемешивает, разделяет и объединяет; параметры, которые он получает; навыки, которые он прокачивает. Подозреваю, что герой должен хранить в себе 4-5 коллекции, в которых указанные параметры хранятся и обрабатываются более упорядоченно. Например:
```Python
class Hero: # 
class HeroStats: # 
class HeroArmy: # 
class HeroSkills: # 
```
и т. д.
Почему слишком много инстансов класса - это плохой признак, не понял. Приведу 2 примера: 
- в том же геройском клоне на карте может быть расставлено очень много объектов-наследников класса, который передаёт графическому движку себя на отрисовку. Среди них могут быть юниты класса Разбойник, которые отличаются друг от друга только параметром Количество, хотя по лесам их может быть расставлено огромное количество (на карте XL). Единственное плохое, что удаётся здесь подтянуть - слишком однообразные противники. В идеале, повторяемость должна быть как можно ниже, если только это не какая-то экзотическая карта типа "Заброшенный некрополь", где не должно быть большого разнообразия.
- в приложении HHParser есть класс Vacancy. Сколько надо обработать вакансии, столько инстансов этого класса и создаётся. Получается, например, 600 объектов этого класса. Сейчас понимаю, что поскольку весь парсинг вынесен в отдельный класс VacancyParser, полученные капли полезных данных могут сохраняться не в отдельный объект, а разноситься на тематические словари в самом HHParser. Тем более, что из-за необходимости хранить ключевые навыки в отдельном массиве наблюдается частичной дублирование хранимой информации. Возможно, назрел рефакторинг. 

2.2. Вместо присутствующего во многих популярных языках внутреннего типа (класса) time люди создают отдельные классы Hour и Minute, потому что им не нужно секунды, таймзоны и прочий обвес. Беда начинается, когда оказывается, что это обёрнутый int, который существует для красоты, а все проверки, броски исключений и т. п. происходят в том коде, где эти классы используются. Если уж взялся писать классы-обёртки, то все проверки, все границы и все исключения должны обрабатываться и генерироваться в самом классе. 

2.3. В классе Vacancy проекта HHParser была здоровенная функция, которые сначала парсила входящий поток html'а, а потом создавала объект класса Vacancy. После чего происходила пост-обработка данных для "причёсывания" их вида. Впоследствии эта функция была разбита на кучу маленьких функций, каждая из которых получала свою копию куска html'a, и возвращала данные, которые не нужно "причёсывать". Когда стало понятно, что в классе есть 5-6 статических функций, которые просто парсят данные и возвращают результат, вообще не обращая внимания на self, я принял решение вынести всё, что не работает с состоянием Vacancy в отдельный класс VacancyParser. Получилась своеобразная библиотека ФП-функций, которым самое место здесь, а не в старом классе.

2.4. Здесь решение без конкретики, скорее, простая философия политеховского кодирования. Сейчас я искренне убеждён, что рассказывая про ООП на примере C++, Java или Python, второе, о чём должен сказать педагог - это про сокрытие полей. Только закончил рассказывать про то, что такое переменная, почему в ООП называется поле или атрибут, про традиции именования в конкретном ЯВУ - и сразу про зоны видимости. Зачастую именно в политеховских лабах и курсовиках можно увидеть "прекрасные" моменты в стиле `employee.payment = calculated_payment` в самых неожиданных местах кода. Что мешает сделать функцию `set_payment()`, которая, откуда не вызывай, делает конкретное и понятное действие? А в Python есть "прекрасная" возможность записать `employee.hobbie = 'hobbyhorsing'` в любом месте кода, хотя у класса Employee может вообще не быть такого поля. Как я с этим борюсь, я описывал в своём блоге в Телеграме.

2.5. В случае, если программист не знаком с паттернами Фабричный метод и Абстрактная фабрика, его код, обрабатывающий схожие типы данных (ряд потомков одного класса-родителя), будет выглядеть, как цепочка if..else или switch..case. Добавление ещё одного АТД-потомка или изменение в работе имеющегося вызовет необходимость исправления в цепочке if..else обрабатывающего класса. По-моему, это ключевой аргумент против использования не только цепочек if..else, но и против if как такового.

2.6. При чтении отечественных книг по Java ещё в институте (а иногда и на первой своей работе) натыкался на такие вещи:
```Java
class PowerLines(): //общий класс ЛЭП
class AnchorPowerLines(PowerLines): //класс анкерных ЛЭП
/* разные типы ЛЭП */

anchorPowerLines = (AnchorPowerLines) context.getPowerLines()
anchorPowerLines.getObstacle()
```
Ситуация следующая: есть анкерные ЛЭП, которые устанавливают для перехода через естественные преграды и инженерные сооружения. Некий программный контекст принимает для передачи общий класс ЛЭП, а при извлечении их надо преобразовывать. Зачем? Затем, что `getObstacle()`, например, есть только у анкерных ЛЭП. Лёгкость, с которой классы в Java преобразовываются друг в друга вызывает у меня напряжение ещё с тех пор. Компилятор в тем времена на такие вещи не ругался, а плавающие ошибки могли потом долго не давать покоя. 

2.7. Если у нас есть классы Sword, Dagger, Axe, унаследованные от MeleeWeapon, и, соответственно, SwordDamage, DaggerDamage, AxeDamage, унаследованные от MeleeDamage, то создание класса Spear неизбежно влечёт создание SpearDamage. Этого следует избегать, а "поведение" оружия реализовывать через привязку не к оружию, которым наносится повреждение, а через характер нанесения урона (рубящий, колющий, дробящий).

2.8. Допустим, в RPG-проекте воин наносит урон с теми или иными модификаторами/перками/бонусами. Берсерк, "милишный файтер" (то есть воин ближнего боя))), бьёт в состоянии ярости или даже бешенства. Велик соблазн унаследовать от воина и варвара, и паладина, и следопыта, и даже вора, а потом переопределить каждому `attack()`, да ещё и каждую реализацию if..else'ов натолкать побольше. Конечно, лучше даже в мыслях такого не допускать. Надо собрать всё общее, что есть у всех боевых классов ближнего боя в абстрактный класс MeleeFighter, а уже от него реализовывать и базовые классы, и суперклассы. Более того, можно сделать фабрику функций нанесения урона, которая будет возвращать тот или иной метод для ухода от if'ов. Но я так глубоко пока не умею.

3.1. Есть графическая оболочка (на tkinter или dearpygui, неважно), которая получает данные от внутреннего класса, приводит его к печатному виду (вот ошибка!) и отображает в виджете. Следовательно, если меняется формат данных, то меняется и функция внешнего класса, и обработчик GUI. Решение я вижу такое: любую передачу данных от внутреннего класса (бизнес-логика) к внешнему (GUI) проводить с преобразованием данных к формату, используемому в GUI. Тогда изменения во внутреннем устройстве бизнес-логики останутся в одном месте.

3.2. На ум приходит паттерн Observer: если у нас есть некий объект, изменения в котором касается толпы Наблюдателей, при этом их количество может меняться, то лучше использовать этот паттерн. Но если у нас всего две сущности, в первой происходят изменения состояния, во второй - реакция на них, то проще в первой сущности в конце функции `update()` вызывать публичный метод `react()` (или `calculate()`, или `change()`) второй сущности.