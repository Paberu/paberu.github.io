Начну, пожалуй, с извинений. Я выбрал не самый удачный проект для выполнения этого задания: приложение по учёту прочитанных книг с мнениями, отзывами и оценками. Полностью автономный десктоп, никаких клиент-серверных заморочек, вместо СУБД - сохранение в локальный JSON. Как сказал один мудрец, 80% полезных приложений - это excel-файл с более удобным интерфейсом. И тем не менее, кое-какие выводы сделать получилось.

Начал разрабатывать чисто по TDD: сначала написал тесты для класса Book. В тетрадке перечислены поля класса, среди которых есть как обязательные, так и необязательные, поэтому есть несколько тестов для неверного вызова конструктора, верного вызова с неполным набором полей, и с полным набором полей. Так же есть проверка получения и задания значения для поля title. Потом создал класс Book, добился прохождения тестов.

Потом создал тесты для класса BookOpinion, в котором присутствует список книг, и пара-тройка методов по получению, добавлению и удалению книги из списка. Подключение GUI-библиотеки и настройка внешнего вида приложения происходит в этом же файле после проверки `if __name__ == 'main':`.
Уже на это моменте я насторожился - способ создания приложения согласно официальной документации противоречит здравому смыслу. Как и первоначальный метод организации приложения.

Начитавшись материалов про три уровня рассуждений о программе я задумался, почему у меня все методы и все поля классов публичные. Да, Python не Java и не C++, в нём нет очевидных public/private/protected, но это не должно подталкивать к созданию приложений a-la белый ящик. Даже не белый, а прозрачный.

Все поля автоматически должны стать private, а вместо геттеров и сеттеров (опции по автоматическому созданию геттеров и сеттеров для всех полей класса присутствуют, например, в любой IDE для Java) я спроектировал ровно два метода: get_field() и set_field(). Столкнулся с неприятной особенностью Python: при использовании метода set_attribute интерпретатору всё равно, существует такое поле или нет. Его всегда можно создать, больше полей богу полей! Я решил, что на уровне класса должен быть кортеж, в котором перечислены имена полей, которые могут содержаться в классе. Все геттеры и сеттеры свелись к двум методам:
```Python
def get_field(self, field_name):
	return getattr(self, field_name)

def set_field(self, field_name, value):
	if field_name in self.BOOK_FIELDS:
		setattr(self, field_name, value)
	else:
		raise AttributeError('Нельзя создавать новые поля')
```
 Хороший пример первоначального кода (правда, уже с исправлениями в виде get_field/set_field) здесь:
 https://github.com/Paberu/BookOpinion/tree/cd549976bd884ae263a482ccb7c549a05d3d15bd
  
 Сейчас вспомнились предыдущие занятие: в блоке if можно проверять имя поля на вхождение в кортеж, и потом бросать исключение или отрабатывать штатно. И не нужен else.
```Python
def get_field(self, field_name):  
    if field_name not in self.BOOK_FIELDS:  
        raise AttributeError('Нельзя создавать новые поля')  
    return getattr(self, field_name)  
  
def set_field(self, field_name, value):  
    if field_name not in self.BOOK_FIELDS:  
        raise AttributeError('Нельзя создавать новые поля')  
    setattr(self, field_name, value)
```

Весь важный код, создающий собственно интерфейс был перенесён в один из методов класса BookOpinion. Каждая функция-слушатель реализована так же как метод класса. Чтобы всё работало, применена композиция: объект dearpygui.dearpygui является одним из параметров экземпляра BookOpinion, поэтому и стала возможной такая оптимизация. 

В новом дизайне добавление кнопок или интерактивных элементов легко предварять написание пары тестов, достаточно понимать, как устроена передача пользовательских данных в конкретном GUI. Я, в свою очередь, сначала расписал возможное поведение функций в бумаге, потом реализовал их в коде, и уже в момент переноса "бесхозных" функций в класс BookOpinion понял, как можно было скомпоновать более адекватное TDD.

И тем не менее, смысл функций, их разбиение на составные, более мелкие, и возможное поведение (включая отклонения) сначала были спроектированы на бумаге, и уже под этот проект начали подводиться тесты и код. Надеюсь, можно считать, что после такого перепроектирования и код, и тесты, соответствуют проекту, хотя последних и недостаточно по указанным выше причинам.

Текущий код проекта:
https://github.com/Paberu/BookOpinion